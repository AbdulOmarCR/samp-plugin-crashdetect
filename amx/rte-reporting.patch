diff -ruNpw amx_orig/amx.c amx/amx.c
--- amx_orig/amx.c	2005-07-23 18:57:50.000000000 +0700
+++ amx/amx.c	2012-04-26 09:33:38.437227400 +0700
@@ -21,6 +21,17 @@
  *  Version: $Id: amx.c 3365 2005-07-23 15:57:48Z thiadmer $
  */
 
+/* This is a slightly modified version of the original file, specially for crashdetect.
+ *   - ABORT() synchronizes AMX registers with amx_Exec()'s local variables
+ *   - ABORT() calls external error handler amx_Error(AMX *amx, cell index, int error),
+ *     where "error" is the error code and "index" is the index of the current public
+ *   - CHKSTACK(), CHKMARGIN() and CHKHEAP() now use the ABORT() macro instead of return
+ *   - The CIP register (amx->cip) is updated on each iteration of the instruction dispatch loop
+ *   - The CALL.pri and JUMP.pri opcodes have been removed
+ *   - The LREF.S.pri/alt and SREF.S.pri/alt opcodes synchronize the STK and FRM registers before
+ *     before pointer dereferencing because of a possible crash 
+ */
+
 #if BUILD_PLATFORM == WINDOWS && BUILD_TYPE == RELEASE && BUILD_COMPILER == MSVC && PAWN_CELL_SIZE == 64
   /* bad bad workaround but we have to prevent a compiler crash :/ */
   #pragma optimize("g",off)
@@ -1655,18 +1666,25 @@ int AMXAPI amx_PushString(AMX *amx, cell
 #define SKIPPARAM(n)    ( cip=(cell *)cip+(n) )
 #define PUSH(v)         ( stk-=sizeof(cell), *(cell *)(data+(int)stk)=v )
 #define POP(v)          ( v=*(cell *)(data+(int)stk), stk+=sizeof(cell) )
-#define ABORT(amx,v)    { (amx)->stk=reset_stk; (amx)->hea=reset_hea; return v; }
-
-#define CHKMARGIN()     if (hea+STKMARGIN>stk) return AMX_ERR_STACKERR
-#define CHKSTACK()      if (stk>amx->stp) return AMX_ERR_STACKLOW
-#define CHKHEAP()       if (hea<amx->hlw) return AMX_ERR_HEAPLOW
+#define ABORT(amx,v)    { (amx)->pri = pri;\
+						  (amx)->stk = stk;\
+						  (amx)->hea = hea;\
+						  (amx)->frm = frm;\
+						  amx_Error(amx, index, v);\
+                          (amx)->stk=reset_stk;\
+                          (amx)->hea=reset_hea;\
+                          return v; }
+
+#define CHKMARGIN()     if (hea+STKMARGIN>stk) ABORT(amx, AMX_ERR_STACKERR)
+#define CHKSTACK()      if (stk>amx->stp) ABORT(amx, AMX_ERR_STACKLOW)
+#define CHKHEAP()       if (hea<amx->hlw) ABORT(amx, AMX_ERR_HEAPLOW)
 
 #if defined __GNUC__ && !(defined ASM32 || defined JIT)
     /* GNU C version uses the "labels as values" extension to create
      * fast "indirect threaded" interpreter.
      */
 
-#define NEXT(cip)       goto **cip++
+#define NEXT(cip)       do { (amx)->cip=(cell)cip-(cell)code; goto **cip++; } while (0)
 
 int AMXAPI amx_Exec(AMX *amx, cell *retval, int index)
 {
@@ -2777,6 +2795,7 @@ int AMXAPI amx_Exec(AMX *amx, cell *retv
 #else
 
   for ( ;; ) {
+    amx->cip=(cell)cip-(cell)code;
     op=(OPCODE) *cip++;
     switch (op) {
     case OP_LOAD_PRI:
@@ -2806,11 +2825,15 @@ int AMXAPI amx_Exec(AMX *amx, cell *retv
       alt= * (cell *)(data+(int)offs);
       break;
     case OP_LREF_S_PRI:
+      amx->frm=frm;
+      amx->stk=stk;
       GETPARAM(offs);
       offs= * (cell *)(data+(int)frm+(int)offs);
       pri= * (cell *)(data+(int)offs);
       break;
     case OP_LREF_S_ALT:
+      amx->frm=frm;
+      amx->stk=stk;  
       GETPARAM(offs);
       offs= * (cell *)(data+(int)frm+(int)offs);
       alt= * (cell *)(data+(int)offs);
@@ -2869,11 +2892,15 @@ int AMXAPI amx_Exec(AMX *amx, cell *retv
       *(cell *)(data+(int)frm+(int)offs)=alt;
       break;
     case OP_SREF_PRI:
+      amx->frm=frm;
+      amx->stk=stk;
       GETPARAM(offs);
       offs= * (cell *)(data+(int)offs);
       *(cell *)(data+(int)offs)=pri;
       break;
     case OP_SREF_ALT:
+      amx->frm = frm;
+      amx->stk = stk;
       GETPARAM(offs);
       offs= * (cell *)(data+(int)offs);
       *(cell *)(data+(int)offs)=alt;
@@ -3076,10 +3103,6 @@ int AMXAPI amx_Exec(AMX *amx, cell *retv
       PUSH(((unsigned char *)cip-code)+sizeof(cell));/* skip address */
       cip=JUMPABS(code, cip);                   /* jump to the address */
       break;
-    case OP_CALL_PRI:
-      PUSH((unsigned char *)cip-code);
-      cip=(cell *)(code+(int)pri);
-      break;
     case OP_JUMP:
       /* since the GETPARAM() macro modifies cip, you cannot
        * do GETPARAM(cip) directly */
@@ -3484,9 +3507,6 @@ int AMXAPI amx_Exec(AMX *amx, cell *retv
     case OP_SYMTAG:
       SKIPPARAM(1);
       break;
-    case OP_JUMP_PRI:
-      cip=(cell *)(code+(int)pri);
-      break;
     case OP_SWITCH: {
       cell *cptr;
 
diff -ruNpw amx_orig/amx.h amx/amx.h
--- amx_orig/amx.h	2005-07-23 17:07:00.000000000 +0700
+++ amx/amx.h	2012-04-26 09:33:38.437227400 +0700
@@ -21,6 +21,8 @@
  *  Version: $Id: amx.h 3363 2005-07-23 09:03:29Z thiadmer $
  */
 
+#include <stddef.h>
+
 #if defined FREEBSD && !defined __FreeBSD__
   #define __FreeBSD__
 #endif
@@ -371,6 +373,7 @@ int AMXAPI amx_Allot(AMX *amx, int cells
 int AMXAPI amx_Callback(AMX *amx, cell index, cell *result, cell *params);
 int AMXAPI amx_Cleanup(AMX *amx);
 int AMXAPI amx_Clone(AMX *amxClone, AMX *amxSource, void *data);
+int AMXAPI amx_Error(AMX *amx, cell index, int error);
 int AMXAPI amx_Exec(AMX *amx, cell *retval, int index);
 int AMXAPI amx_FindNative(AMX *amx, const char *name, int *index);
 int AMXAPI amx_FindPublic(AMX *amx, const char *funcname, int *index);
